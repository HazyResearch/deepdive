#!/usr/bin/env bash
# db-assign_sequential_id -- Assigns a unique integer to every row for a table using PostgreSQL sequence generator
# > eval "$(db-parse "$url")"
# > db-assign_sequential_id TABLE COLUMN BEGIN_ID [INCREMENT]
##
set -euo pipefail

[[ $# -gt 0 ]] || usage "$0" "Missing TABLE"
[[ $# -gt 1 ]] || usage "$0" "Missing COLUMN"
[[ $# -gt 2 ]] || usage "$0" "Missing BEGIN_ID"
Table=$1 Column=$2 BeginId=$3 Increment=${4:-1}

# Use Greenplum PL/pgSQL and PL/Python UDFs to assign IDs fast
# See: http://www.postgresql.org/docs/8.2/static/sql-createlanguage.html
# See: http://www.postgresql.org/docs/8.2/static/plpgsql-overview.html
# See: http://www.postgresql.org/docs/8.2/static/plpython-funcs.html
if db-supports_pg_lang "plpgsql" && db-supports_pg_lang "plpythonu"; then
    db-execute "
    CREATE OR REPLACE FUNCTION fast_seqassign_init()
    RETURNS INT AS \$\$
      if 'cumulative_cnt' in SD:
        SD.pop('cumulative_cnt')
      return 0
    \$\$ LANGUAGE plpythonu;

    CREATE OR REPLACE FUNCTION fast_seqassign_next(startid BIGINT, increment BIGINT, this_gpsid INT, gpsids INT[], cumulative_cnts BIGINT[], cnts BIGINT[])
    RETURNS BIGINT AS \$\$
      if 'cumulative_cnt' not in SD:
        for gpsid, cumulative_cnt, cnt in zip(gpsids, cumulative_cnts, cnts):
          if gpsid == this_gpsid:
            # assignment is done using the cumulative count for this segment and a decrementing counter from the size of this segment down to one
            SD['cumulative_cnt'] = cumulative_cnt
            SD['remaining'] = cnt
            break
      if 'cumulative_cnt' in SD and SD['remaining'] > 0:
        id = startid + increment * (SD['cumulative_cnt'] - SD['remaining'])
        SD['remaining'] = SD['remaining'] - 1
        if SD['remaining'] <= 0:
          SD.pop('cumulative_cnt')
        return id
      else:
        # XXX no segment was found
        raise plpy.ERROR('No non-empty id range was assigned for segment %s in the initial partition' % str(this_gpsid))
    \$\$ LANGUAGE plpythonu;

    CREATE OR REPLACE FUNCTION fast_seqassign(tname CHARACTER VARYING, cname CHARACTER VARYING, startid BIGINT, increment BIGINT)
    RETURNS TEXT AS \$\$
    BEGIN
      EXECUTE 'CREATE TEMPORARY VIEW dd_tmp_id_ranges_by_gpsid AS
               SELECT gpsid
                    , cnt
                    , SUM(cnt) OVER (ORDER BY gpsid) AS cumulative_cnt
                 FROM (
                    SELECT gp_segment_id AS gpsid
                         , COUNT(1)      AS cnt
                      FROM ' || QUOTE_IDENT(tname) || '
                     GROUP BY gpsid
                     ORDER BY gpsid
                 ) histogram;';
      DECLARE
        gpsids          INT[]    := ARRAY(SELECT gpsid          FROM dd_tmp_id_ranges_by_gpsid ORDER BY gpsid);
        cumulative_cnts BIGINT[] := ARRAY(SELECT cumulative_cnt FROM dd_tmp_id_ranges_by_gpsid ORDER BY gpsid);
        cnts            BIGINT[] := ARRAY(SELECT cnt            FROM dd_tmp_id_ranges_by_gpsid ORDER BY gpsid);
      BEGIN
        EXECUTE 'SELECT fast_seqassign_init();';
        EXECUTE 'UPDATE ' || tname || ' SET ' || cname || ' = fast_seqassign_next(
            ' || startid || ',
            ' || increment || ',
            gp_segment_id,
            ARRAY[' || ARRAY_TO_STRING(         gpsids, ',')::TEXT || '],
            ARRAY[' || ARRAY_TO_STRING(cumulative_cnts, ',')::TEXT || '],
            ARRAY[' || ARRAY_TO_STRING(           cnts, ',')::TEXT || ']
          );';
        RETURN 'fast_seqassign done for segments [' || ARRAY_TO_STRING(gpsids, ',') || ']' ||
               ' with counts [' || ARRAY_TO_STRING(cnts, ',') || ']';
      END;
    END;
    \$\$ LANGUAGE 'plpgsql';

    SELECT fast_seqassign('$Table', '$Column', $BeginId, $Increment);
"

else # if either plpgsql or plpythonu is not available
# Fall back to using PostgreSQL sequence generator named after the table and column
# See: http://www.postgresql.org/docs/current/static/sql-createsequence.html
seq="dd_seq_${Table}_${Column}"
deepdive sql "
    DROP SEQUENCE IF EXISTS $seq CASCADE;
    CREATE TEMPORARY SEQUENCE $seq INCREMENT BY $Increment MINVALUE $(($BeginId - 1)) START $BeginId;

    UPDATE $Table SET $Column = nextval('$seq');
"
fi
