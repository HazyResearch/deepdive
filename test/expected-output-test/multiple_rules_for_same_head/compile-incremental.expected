
  deepdive.db.default {
    driver: "org.postgresql.Driver"
    url: "jdbc:postgresql://"${PGHOST}":"${PGPORT}"/"${DBNAME}
    user: ${PGUSER}
    password: ${PGPASSWORD}
    dbname: ${DBNAME}
    host: ${PGHOST}
    port: ${PGPORT}
    incremental_mode: INCREMENTAL
    }
    

      deepdive.schema.keys {
        dd_new_Q : [x]
        dd_delta_Q : [x]
      }

      deepdive.schema.variables {
        Q.label: Boolean
dd_delta_Q.label: Boolean
dd_new_Q.label: Boolean
      }
    

          deepdive.extraction.extractors.init_dd_new_S {
            sql: """ DROP TABLE IF EXISTS dd_new_S CASCADE;
            CREATE TABLE
            dd_new_S(a int)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.init_dd_delta_T {
            sql: """ DROP TABLE IF EXISTS dd_delta_T CASCADE;
            CREATE TABLE
            dd_delta_T(a int)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.init_dd_new_T {
            sql: """ DROP TABLE IF EXISTS dd_new_T CASCADE;
            CREATE TABLE
            dd_new_T(a int)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.init_dd_delta_S {
            sql: """ DROP TABLE IF EXISTS dd_delta_S CASCADE;
            CREATE TABLE
            dd_delta_S(a int)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.init_dd_new_R {
            sql: """ DROP TABLE IF EXISTS dd_new_R CASCADE;
            CREATE TABLE
            dd_new_R(a int,
        b int)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.init_dd_delta_R {
            sql: """ DROP TABLE IF EXISTS dd_delta_R CASCADE;
            CREATE TABLE
            dd_delta_R(a int,
          b int)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.init_dd_delta_Q {
            sql: """ DROP TABLE IF EXISTS dd_delta_Q CASCADE;
            CREATE TABLE
            dd_delta_Q(x int,
          id bigint,
          label boolean)
            """
            style: "sql_extractor"
          }

        deepdive.extraction.extractors.cleanup {
          sql: """
          TRUNCATE dd_new_S;
          TRUNCATE dd_delta_T;
          TRUNCATE dd_new_T;
          TRUNCATE dd_delta_S;
          TRUNCATE dd_new_R;
          TRUNCATE dd_delta_R;
          TRUNCATE dd_delta_Q;
          """
          style: "sql_extractor"
        }

      deepdive.extraction.extractors.ext_dd_new_S {
        sql: """ TRUNCATE dd_new_S;
        INSERT INTO dd_new_S SELECT R0.a
FROM S R0
        
UNION ALL
SELECT R0.a
FROM dd_delta_S R0
        
        """
          output_relation: "dd_new_S"
        style: "sql_extractor"
          dependencies: [ "ext_dd_delta_S" ,  "ext1_dd_delta_S_by_f" ,  "ext_dd_delta_S_by_f" ,  "ext_dd_delta_S_by_f_1" ]
          input_relations: [
            S
            dd_delta_S
          ]
      }
    

      deepdive.extraction.extractors.ext_dd_new_T {
        sql: """ TRUNCATE dd_new_T;
        INSERT INTO dd_new_T SELECT R0.a
FROM T R0
        
UNION ALL
SELECT R0.a
FROM dd_delta_T R0
        
        """
          output_relation: "dd_new_T"
        style: "sql_extractor"
          dependencies: [ "ext_dd_delta_T_by_f" ,  "ext1_dd_delta_T_by_f" ,  "ext2_dd_delta_T_by_f" ,  "ext_dd_delta_T_by_f_1" ]
          input_relations: [
            T
            dd_delta_T
          ]
      }
    

      deepdive.extraction.extractors.ext_dd_delta_S {
        sql: """ 
        INSERT INTO dd_delta_S SELECT R0.a AS "dd_delta_R.R0.a"
FROM dd_delta_R R0, R R1
        WHERE R1.a = R0.b  AND R0.a > 100
UNION ALL
SELECT R0.a AS "dd_new_R.R0.a"
FROM dd_new_R R0, dd_delta_R R1
        WHERE R1.a = R0.b  AND R0.a > 100
UNION ALL
SELECT R0.a AS "dd_delta_R.R0.a"
FROM dd_delta_R R0, R R1
        WHERE R1.a = R0.b  AND R0.a < -100
UNION ALL
SELECT R0.a AS "dd_new_R.R0.a"
FROM dd_new_R R0, dd_delta_R R1
        WHERE R1.a = R0.b  AND R0.a < -100
UNION ALL
SELECT R0.a AS "dd_delta_R.R0.a"
FROM dd_delta_R R0, R R1
        WHERE R1.a = R0.b  AND R0.a = 0
UNION ALL
SELECT R0.a AS "dd_new_R.R0.a"
FROM dd_new_R R0, dd_delta_R R1
        WHERE R1.a = R0.b  AND R0.a = 0
        """
          output_relation: "dd_delta_S"
        style: "sql_extractor"
          dependencies: [ "ext_dd_new_R" ]
          input_relations: [
            dd_delta_R
            R
            dd_new_R
          ]
      }
    

      deepdive.extraction.extractors.ext_dd_new_R {
        sql: """ TRUNCATE dd_new_R;
        INSERT INTO dd_new_R SELECT R0.a, R0.b
FROM R R0
        
UNION ALL
SELECT R0.a, R0.b
FROM dd_delta_R R0
        
        """
          output_relation: "dd_new_R"
        style: "sql_extractor"
          
          input_relations: [
            R
            dd_delta_R
          ]
      }
    

      deepdive.extraction.extractors.ext_dd_new_Q {
        sql: """ 
        CREATE VIEW dd_new_Q AS SELECT DISTINCT R0.x, id, label
          FROM Q R0
        
          
UNION ALL
SELECT DISTINCT R0.x, id, label
          FROM dd_delta_Q R0
        
          
        """
          output_relation: "dd_new_Q"
        style: "sql_extractor"
          
          input_relations: [
            Q
            dd_delta_Q
          ]
      }
    

        deepdive.extraction.extractors.ext_dd_delta_T_by_f {
          input: """ SELECT R0.a AS "dd_delta_R.R0.a", R0.b AS "dd_delta_R.R0.b"
FROM dd_delta_R R0
        WHERE R0.a > 1000
          """
          output_relation: "dd_delta_T"
          udf: ${APP_HOME}"//bin/false"
          style: "tsv_extractor" 
          
          input_relations: [
            dd_delta_R
          ]
          input_batch_size: ${INPUT_BATCH_SIZE}
          parallelism: ${PARALLELISM}
        }
      

        deepdive.extraction.extractors.ext1_dd_delta_T_by_f {
          input: """ SELECT R0.a AS "dd_delta_R.R0.a", R0.b AS "dd_delta_R.R0.b"
FROM dd_delta_R R0
        WHERE (10 < R0.a AND R0.a < 20)
          """
          output_relation: "dd_delta_T"
          udf: ${APP_HOME}"//bin/false"
          style: "tsv_extractor" 
          
          input_relations: [
            dd_delta_R
          ]
          input_batch_size: ${INPUT_BATCH_SIZE}
          parallelism: ${PARALLELISM}
        }
      

        deepdive.extraction.extractors.ext2_dd_delta_T_by_f {
          input: """ SELECT R0.a AS "dd_delta_R.R0.a", R0.b AS "dd_delta_R.R0.b"
FROM dd_delta_R R0
        WHERE (100 < R0.a AND R0.a < 200)
          """
          output_relation: "dd_delta_T"
          udf: ${APP_HOME}"//bin/false"
          style: "tsv_extractor" 
          
          input_relations: [
            dd_delta_R
          ]
          input_batch_size: ${INPUT_BATCH_SIZE}
          parallelism: ${PARALLELISM}
        }
      

        deepdive.extraction.extractors.ext_dd_delta_S_by_f {
          input: """ SELECT R0.a AS "dd_delta_R.R0.a", R0.b AS "dd_delta_R.R0.b"
FROM dd_delta_R R0
        WHERE R0.a < 0
          """
          output_relation: "dd_delta_S"
          udf: ${APP_HOME}"//bin/false"
          style: "tsv_extractor" 
          
          input_relations: [
            dd_delta_R
          ]
          input_batch_size: ${INPUT_BATCH_SIZE}
          parallelism: ${PARALLELISM}
        }
      

        deepdive.extraction.extractors.ext1_dd_delta_S_by_f {
          input: """ SELECT R0.a AS "dd_delta_R.R0.a", R0.b AS "dd_delta_R.R0.b"
FROM dd_delta_R R0
        WHERE R0.a > 0
          """
          output_relation: "dd_delta_S"
          udf: ${APP_HOME}"//bin/false"
          style: "tsv_extractor" 
          
          input_relations: [
            dd_delta_R
          ]
          input_batch_size: ${INPUT_BATCH_SIZE}
          parallelism: ${PARALLELISM}
        }
      

        deepdive.extraction.extractors.ext_dd_delta_T_by_f_1 {
          input: """ SELECT R0.a AS "dd_delta_R.R0.a", R0.b AS "dd_delta_R.R0.b"
FROM dd_delta_R R0
        
          """
          output_relation: "dd_delta_T"
          udf: ${APP_HOME}"//bin/false"
          style: "tsv_extractor" 
          
          input_relations: [
            dd_delta_R
          ]
          input_batch_size: ${INPUT_BATCH_SIZE}
          parallelism: ${PARALLELISM}
        }
      

        deepdive.extraction.extractors.ext_dd_delta_S_by_f_1 {
          input: """ SELECT R0.a AS "dd_delta_R.R0.a", R0.b AS "dd_delta_R.R0.b"
FROM dd_delta_R R0
        WHERE R0.a > 0
          """
          output_relation: "dd_delta_S"
          udf: ${APP_HOME}"//bin/false"
          style: "tsv_extractor" 
          
          input_relations: [
            dd_delta_R
          ]
          input_batch_size: ${INPUT_BATCH_SIZE}
          parallelism: ${PARALLELISM}
        }
      

        deepdive.inference.factors.dd_delta_inf_istrue_Q {
          input_query: """
          SELECT R0.id AS "dd_new_Q.R0.id" , R0.x AS "dd_weight_column_0" 
          FROM dd_new_Q R0, dd_delta_S R1
        WHERE R1.a = R0.x  AND R0.x > 1000"""
          function: "Imply(dd_new_Q.R0.label)"
          weight: "?(dd_weight_column_0)"
          dependencies: [ "ext_dd_delta_S" ,  "ext1_dd_delta_S_by_f" ,  "ext_dd_delta_S_by_f" ,  "ext_dd_delta_S_by_f_1" ]
          input_relations: [
            dd_new_Q
            dd_delta_S
          ]
        }
      

        deepdive.inference.factors.dd_delta_inf1_istrue_Q {
          input_query: """
          SELECT R0.id AS "dd_new_Q.R0.id" 
          FROM dd_new_Q R0, dd_delta_S R1
        WHERE R1.a = R0.x  AND R0.x = 0"""
          function: "Imply(dd_new_Q.R0.label)"
          weight: "1.0"
          dependencies: [ "ext_dd_delta_S" ,  "ext1_dd_delta_S_by_f" ,  "ext_dd_delta_S_by_f" ,  "ext_dd_delta_S_by_f_1" ]
          input_relations: [
            dd_new_Q
            dd_delta_S
          ]
        }
      

        deepdive.inference.factors.dd_delta_inf_imply_Q_Q {
          input_query: """
          SELECT R0.id AS "dd_new_Q.R0.id" , R1.id AS "dd_new_Q.R1.id" , R0.x AS "dd_weight_column_0" 
          FROM dd_new_Q R0, dd_new_Q R1, dd_delta_S R2, R R3, S R4
        WHERE R2.a = R0.x  AND R3.a = R0.x  AND R3.b = R1.x  AND R4.a = R1.x  UNION ALL 
          SELECT R0.id AS "dd_new_Q.R0.id" , R1.id AS "dd_new_Q.R1.id" , R0.x AS "dd_weight_column_0" 
          FROM dd_new_Q R0, dd_new_Q R1, dd_new_S R2, dd_delta_R R3, S R4
        WHERE R2.a = R0.x  AND R3.a = R0.x  AND R3.b = R1.x  AND R4.a = R1.x  UNION ALL 
          SELECT R0.id AS "dd_new_Q.R0.id" , R1.id AS "dd_new_Q.R1.id" , R0.x AS "dd_weight_column_0" 
          FROM dd_new_Q R0, dd_new_Q R1, dd_new_S R2, dd_new_R R3, dd_delta_S R4
        WHERE R2.a = R0.x  AND R3.a = R0.x  AND R3.b = R1.x  AND R4.a = R1.x """
          function: "Imply(dd_new_Q.R0.label, dd_new_Q.R1.label)"
          weight: "?(dd_weight_column_0)"
          dependencies: [ "ext_dd_new_R" ,  "ext_dd_delta_S_by_f" ,  "ext1_dd_delta_S_by_f" ,  "ext_dd_new_S" ,  "ext_dd_delta_S_by_f_1" ,  "ext_dd_delta_S" ]
          input_relations: [
            dd_new_Q
            dd_delta_S
            R
            S
            dd_new_S
            dd_delta_R
            dd_new_R
          ]
        }
      

        deepdive.inference.factors.dd_delta_inf1_imply_Q_Q {
          input_query: """
          SELECT R0.id AS "dd_new_Q.R0.id" , R1.id AS "dd_new_Q.R1.id" 
          FROM dd_new_Q R0, dd_new_Q R1, dd_delta_S R2, R R3, S R4
        WHERE R2.a = R0.x  AND R3.a = R0.x  AND R3.b = R1.x  AND R4.a = R1.x  AND (R0.x + R1.x) < 1000 UNION ALL 
          SELECT R0.id AS "dd_new_Q.R0.id" , R1.id AS "dd_new_Q.R1.id" 
          FROM dd_new_Q R0, dd_new_Q R1, dd_new_S R2, dd_delta_R R3, S R4
        WHERE R2.a = R0.x  AND R3.a = R0.x  AND R3.b = R1.x  AND R4.a = R1.x  AND (R0.x + R1.x) < 1000 UNION ALL 
          SELECT R0.id AS "dd_new_Q.R0.id" , R1.id AS "dd_new_Q.R1.id" 
          FROM dd_new_Q R0, dd_new_Q R1, dd_new_S R2, dd_new_R R3, dd_delta_S R4
        WHERE R2.a = R0.x  AND R3.a = R0.x  AND R3.b = R1.x  AND R4.a = R1.x  AND (R0.x + R1.x) < 1000"""
          function: "Imply(dd_new_Q.R0.label, dd_new_Q.R1.label)"
          weight: "-10.0"
          dependencies: [ "ext_dd_new_R" ,  "ext_dd_delta_S_by_f" ,  "ext1_dd_delta_S_by_f" ,  "ext_dd_new_S" ,  "ext_dd_delta_S_by_f_1" ,  "ext_dd_delta_S" ]
          input_relations: [
            dd_new_Q
            dd_delta_S
            R
            S
            dd_new_S
            dd_delta_R
            dd_new_R
          ]
        }
      
deepdive.pipeline.run: ${PIPELINE}
deepdive.pipeline.pipelines.extraction: [
  ext_dd_new_R
  ext_dd_delta_T_by_f
  ext1_dd_delta_T_by_f
  ext2_dd_delta_T_by_f
  ext_dd_delta_S
  ext_dd_new_T
  ext_dd_new_S
  ext_dd_delta_S_by_f
  ext_dd_new_Q
  ext_dd_delta_S_by_f_1
  ext_dd_delta_T_by_f_1
  ext1_dd_delta_S_by_f
]
deepdive.pipeline.pipelines.inference: [
  dd_delta_inf_istrue_Q
  dd_delta_inf1_istrue_Q
  dd_delta_inf_imply_Q_Q
  dd_delta_inf1_imply_Q_Q
]
deepdive.pipeline.pipelines.endtoend: [
  ext_dd_new_R
  ext_dd_delta_T_by_f
  ext1_dd_delta_T_by_f
  ext2_dd_delta_T_by_f
  ext_dd_delta_S
  ext_dd_new_T
  ext_dd_new_S
  ext_dd_delta_S_by_f
  ext_dd_new_Q
  ext_dd_delta_S_by_f_1
  ext_dd_delta_T_by_f_1
  ext1_dd_delta_S_by_f
  dd_delta_inf_istrue_Q
  dd_delta_inf1_istrue_Q
  dd_delta_inf_imply_Q_Q
  dd_delta_inf1_imply_Q_Q
]
deepdive.pipeline.base_dir: ${BASEDIR}
deepdive.pipeline.pipelines.initdb: [
  init_dd_new_S
  init_dd_delta_T
  init_dd_new_T
  init_dd_delta_S
  init_dd_new_R
  init_dd_delta_R
  init_dd_new_Q
  init_dd_delta_Q
]
deepdive.pipeline.pipelines.cleanup: [
  cleanup
]
