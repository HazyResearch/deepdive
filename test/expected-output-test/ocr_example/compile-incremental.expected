
  deepdive.db.default {
    driver: "org.postgresql.Driver"
    url: "jdbc:postgresql://"${PGHOST}":"${PGPORT}"/"${DBNAME}
    user: ${PGUSER}
    password: ${PGPASSWORD}
    dbname: ${DBNAME}
    host: ${PGHOST}
    port: ${PGPORT}
    incremental_mode: INCREMENTAL
    }
    

      deepdive.schema.keys {
        dd_new_q1 : [wid]
        dd_delta_q2 : [wid]
        dd_delta_q1 : [wid]
        dd_new_q2 : [wid]
      }

      deepdive.schema.variables {
        dd_delta_q1.label: Boolean
dd_new_q2.label: Boolean
dd_new_q1.label: Boolean
q2.label: Boolean
dd_delta_q2.label: Boolean
q1.label: Boolean
      }
    

          deepdive.extraction.extractors.init_dd_new_label2 {
            sql: """ DROP TABLE IF EXISTS dd_new_label2 CASCADE;
            CREATE TABLE
            dd_new_label2(wid INT,
             val BOOLEAN)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.init_dd_delta_label1 {
            sql: """ DROP TABLE IF EXISTS dd_delta_label1 CASCADE;
            CREATE TABLE
            dd_delta_label1(wid INT,
               val BOOLEAN)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.init_dd_new_label1 {
            sql: """ DROP TABLE IF EXISTS dd_new_label1 CASCADE;
            CREATE TABLE
            dd_new_label1(wid INT,
             val BOOLEAN)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.init_dd_delta_features {
            sql: """ DROP TABLE IF EXISTS dd_delta_features CASCADE;
            CREATE TABLE
            dd_delta_features(id BIGSERIAL,
                 word_id INT,
                 feature_id INT,
                 feature_val BOOLEAN)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.init_dd_delta_q2 {
            sql: """ DROP TABLE IF EXISTS dd_delta_q2 CASCADE;
            CREATE TABLE
            dd_delta_q2(wid INT,
           id bigint,
           label boolean)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.init_dd_delta_label2 {
            sql: """ DROP TABLE IF EXISTS dd_delta_label2 CASCADE;
            CREATE TABLE
            dd_delta_label2(wid INT,
               val BOOLEAN)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.init_dd_new_features {
            sql: """ DROP TABLE IF EXISTS dd_new_features CASCADE;
            CREATE TABLE
            dd_new_features(id BIGSERIAL,
               word_id INT,
               feature_id INT,
               feature_val BOOLEAN)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.init_dd_delta_q1 {
            sql: """ DROP TABLE IF EXISTS dd_delta_q1 CASCADE;
            CREATE TABLE
            dd_delta_q1(wid INT,
           id bigint,
           label boolean)
            """
            style: "sql_extractor"
          }

        deepdive.extraction.extractors.cleanup {
          sql: """
          TRUNCATE dd_new_label2;
          TRUNCATE dd_delta_label1;
          TRUNCATE dd_new_label1;
          TRUNCATE dd_delta_features;
          TRUNCATE dd_delta_q2;
          TRUNCATE dd_delta_label2;
          TRUNCATE dd_new_features;
          TRUNCATE dd_delta_q1;
          """
          style: "sql_extractor"
        }

      deepdive.extraction.extractors.ext_dd_new_label2 {
        cmd: """

	# TODO use temporary table
	deepdive create table "dd_new_label2"
	deepdive sql 'INSERT INTO dd_new_label2 SELECT R0.wid, R0.val
FROM label2 R0
        
UNION ALL
SELECT R0.wid, R0.val
FROM dd_delta_label2 R0
        '
	# TODO rename temporary table to replace output_relation
	
        """
          output_relation: "dd_new_label2"
        style: "cmd_extractor"
          
          input_relations: [
            label2
            dd_delta_label2
          ]
      }
    

      deepdive.extraction.extractors.ext_dd_new_q1 {
        cmd: """

	deepdive create view dd_new_q1 as 'SELECT DISTINCT R0.wid, id, label
          FROM q1 R0
        
          
UNION ALL
SELECT DISTINCT R0.wid, id, label
          FROM dd_delta_q1 R0
        
          '
	
        """
          output_relation: "dd_new_q1"
        style: "cmd_extractor"
          dependencies: [ "ext_dd_delta_q1" ]
          input_relations: [
            q1
            dd_delta_q1
          ]
      }
    

      deepdive.extraction.extractors.ext_dd_new_label1 {
        cmd: """

	# TODO use temporary table
	deepdive create table "dd_new_label1"
	deepdive sql 'INSERT INTO dd_new_label1 SELECT R0.wid, R0.val
FROM label1 R0
        
UNION ALL
SELECT R0.wid, R0.val
FROM dd_delta_label1 R0
        '
	# TODO rename temporary table to replace output_relation
	
        """
          output_relation: "dd_new_label1"
        style: "cmd_extractor"
          
          input_relations: [
            label1
            dd_delta_label1
          ]
      }
    

      deepdive.extraction.extractors.ext_dd_delta_q2 {
        cmd: """

	# TODO use temporary table
	deepdive create table "dd_delta_q2"
	deepdive sql 'INSERT INTO dd_delta_q2 SELECT DISTINCT R0.wid, 0 AS id, R0.val AS label
          FROM dd_delta_label2 R0
        
          '
	# TODO rename temporary table to replace output_relation
	
        """
          output_relation: "dd_delta_q2"
        style: "cmd_extractor"
          
          input_relations: [
            dd_delta_label2
          ]
      }
    

      deepdive.extraction.extractors.ext_dd_new_features {
        cmd: """

	# TODO use temporary table
	deepdive create table "dd_new_features"
	deepdive sql 'INSERT INTO dd_new_features SELECT R0.id, R0.word_id, R0.feature_id, R0.feature_val
FROM features R0
        
UNION ALL
SELECT R0.id, R0.word_id, R0.feature_id, R0.feature_val
FROM dd_delta_features R0
        '
	# TODO rename temporary table to replace output_relation
	
        """
          output_relation: "dd_new_features"
        style: "cmd_extractor"
          
          input_relations: [
            features
            dd_delta_features
          ]
      }
    

      deepdive.extraction.extractors.ext_dd_delta_q1 {
        cmd: """

	# TODO use temporary table
	deepdive create table "dd_delta_q1"
	deepdive sql 'INSERT INTO dd_delta_q1 SELECT DISTINCT R0.wid, 0 AS id, R0.val AS label
          FROM dd_delta_label1 R0
        
          '
	# TODO rename temporary table to replace output_relation
	
        """
          output_relation: "dd_delta_q1"
        style: "cmd_extractor"
          
          input_relations: [
            dd_delta_label1
          ]
      }
    

      deepdive.extraction.extractors.ext_dd_new_q2 {
        cmd: """

	deepdive create view dd_new_q2 as 'SELECT DISTINCT R0.wid, id, label
          FROM q2 R0
        
          
UNION ALL
SELECT DISTINCT R0.wid, id, label
          FROM dd_delta_q2 R0
        
          '
	
        """
          output_relation: "dd_new_q2"
        style: "cmd_extractor"
          dependencies: [ "ext_dd_delta_q2" ]
          input_relations: [
            q2
            dd_delta_q2
          ]
      }
    

        deepdive.inference.factors.dd_delta_inf_istrue_q1 {
          input_query: """
          SELECT R0.id AS "dd_new_q1.R0.id" , R1.feature_id AS "dd_weight_column_0" 
          FROM dd_new_q1 R0, dd_delta_features R1
        WHERE R1.word_id = R0.wid """
          function: "Imply(dd_new_q1.R0.label)"
          weight: "?(dd_weight_column_0)"
          
          input_relations: [
            dd_new_q1
            dd_delta_features
          ]
        }
      

        deepdive.inference.factors.dd_delta_inf_istrue_q2 {
          input_query: """
          SELECT R0.id AS "dd_new_q2.R0.id" , R1.feature_id AS "dd_weight_column_0" 
          FROM dd_new_q2 R0, dd_delta_features R1
        WHERE R1.word_id = R0.wid """
          function: "Imply(dd_new_q2.R0.label)"
          weight: "?(dd_weight_column_0)"
          
          input_relations: [
            dd_new_q2
            dd_delta_features
          ]
        }
      
deepdive.pipeline.run: ${PIPELINE}
deepdive.pipeline.pipelines.extraction: [
  ext_dd_delta_q1
  ext_dd_new_q1
  ext_dd_new_label1
  ext_dd_new_features
  ext_dd_delta_q2
  ext_dd_new_label2
  ext_dd_new_q2
]
deepdive.pipeline.pipelines.inference: [
  dd_delta_inf_istrue_q1
  dd_delta_inf_istrue_q2
]
deepdive.pipeline.pipelines.endtoend: [
  ext_dd_delta_q1
  ext_dd_new_q1
  ext_dd_new_label1
  ext_dd_new_features
  ext_dd_delta_q2
  ext_dd_new_label2
  ext_dd_new_q2
  dd_delta_inf_istrue_q1
  dd_delta_inf_istrue_q2
]
deepdive.pipeline.base_dir: ${BASEDIR}
deepdive.pipeline.pipelines.initdb: [
  init_dd_new_label2
  init_dd_delta_label1
  init_dd_new_q1
  init_dd_new_label1
  init_dd_delta_features
  init_dd_delta_q2
  init_dd_delta_label2
  init_dd_new_features
  init_dd_delta_q1
  init_dd_new_q2
]
deepdive.pipeline.pipelines.cleanup: [
  cleanup
]
