
  deepdive.db.default {
    driver: "org.postgresql.Driver"
    url: "jdbc:postgresql://"${PGHOST}":"${PGPORT}"/"${DBNAME}
    user: ${PGUSER}
    password: ${PGPASSWORD}
    dbname: ${DBNAME}
    host: ${PGHOST}
    port: ${PGPORT}
    incremental_mode: ORIGINAL
    }
    


      deepdive.schema.variables {
        has_spouse.label: Boolean
      }
    

          deepdive.extraction.extractors.extraction_rule_1 {
            sql: """ DROP TABLE IF EXISTS sentences CASCADE;
            CREATE TABLE
            sentences(document_id text,
         sentence text,
         words text,
         lemma text,
         pos_tags text,
         dependencies text,
         ner_tags text,
         sentence_offset int,
         sentence_id text)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_3 {
            sql: """ DROP TABLE IF EXISTS has_spouse_candidates CASCADE;
            CREATE TABLE
            has_spouse_candidates(person1_id text,
                     person2_id text,
                     sentence_id text,
                     description text,
                     relation_id text,
                     is_true boolean)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_5 {
            sql: """ DROP TABLE IF EXISTS has_spouse CASCADE;
            CREATE TABLE
            has_spouse(relation_id text,
          id bigint,
          label boolean)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_0 {
            sql: """ DROP TABLE IF EXISTS articles CASCADE;
            CREATE TABLE
            articles(article_id text,
        text text)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_4 {
            sql: """ DROP TABLE IF EXISTS has_spouse_features CASCADE;
            CREATE TABLE
            has_spouse_features(relation_id text,
                   feature text)
            """
            style: "sql_extractor"
          }

          deepdive.extraction.extractors.extraction_rule_2 {
            sql: """ DROP TABLE IF EXISTS people_mentions CASCADE;
            CREATE TABLE
            people_mentions(sentence_id text,
               start_position int,
               length int,
               text text,
               mention_id text)
            """
            style: "sql_extractor"
          }

        deepdive.extraction.extractors.cleanup {
          sql: """
          TRUNCATE sentences;
          TRUNCATE has_spouse_candidates;
          TRUNCATE has_spouse;
          TRUNCATE articles;
          TRUNCATE has_spouse_features;
          TRUNCATE people_mentions;
          """
          style: "sql_extractor"
        }

      deepdive.extraction.extractors.extraction_rule_15 {
        sql: """ 
        INSERT INTO has_spouse SELECT DISTINCT R0.relation_id, 0 AS id, R0.is_true AS label
          FROM has_spouse_candidates R0
        
          
        """
        style: "sql_extractor"
          dependencies: [ "extraction_rule_9" ]
      }
    

      deepdive.extraction.extractors.extraction_rule_7 {
        sql: """ DROP VIEW IF EXISTS ext_people_input;
        CREATE VIEW ext_people_input AS 
            SELECT R0.sentence_id AS "sentences.R0.sentence_id" , R0.words AS "sentences.R0.words" , R0.ner_tags AS "sentences.R0.ner_tags" 
            FROM sentences R0
        
        """
        style: "sql_extractor"
          
      }
    

      deepdive.extraction.extractors.extraction_rule_13 {
        sql: """ DROP VIEW IF EXISTS ext_has_spouse_features_input;
        CREATE VIEW ext_has_spouse_features_input AS 
            SELECT R0.words AS "sentences.R0.words" , R1.relation_id AS "has_spouse_candidates.R1.relation_id" , R2.start_position AS "people_mentions.R2.start_position" , R2.length AS "people_mentions.R2.length" , R3.start_position AS "people_mentions.R3.start_position" , R3.length AS "people_mentions.R3.length" 
            FROM sentences R0, has_spouse_candidates R1, people_mentions R2, people_mentions R3
        WHERE R1.sentence_id = R0.sentence_id  AND R2.sentence_id = R0.sentence_id  AND R2.mention_id = R1.person1_id  AND R3.sentence_id = R0.sentence_id  AND R3.mention_id = R1.person2_id 
        """
        style: "sql_extractor"
          dependencies: [ "extraction_rule_9" ,  "extraction_rule_6" ]
      }
    

      deepdive.extraction.extractors.extraction_rule_10 {
        sql: """ DROP VIEW IF EXISTS ext_has_spouse_input;
        CREATE VIEW ext_has_spouse_input AS 
            SELECT R0.sentence_id AS "people_mentions.R0.sentence_id" , R0.mention_id AS "people_mentions.R0.mention_id" , R0.text AS "people_mentions.R0.text" , R1.mention_id AS "people_mentions.R1.mention_id" , R1.text AS "people_mentions.R1.text" 
            FROM people_mentions R0, people_mentions R1
        WHERE R1.sentence_id = R0.sentence_id 
        """
        style: "sql_extractor"
          dependencies: [ "extraction_rule_6" ]
      }
    

        deepdive.extraction.extractors.extraction_rule_6 {
          input: """ SELECT * FROM ext_people_input
          """
          output_relation: "people_mentions"
          udf: ${APP_HOME}"/udf/ext_people.py"
          style: "tsv_extractor" 
          dependencies: [ "extraction_rule_7" ]
        }
      

        deepdive.extraction.extractors.extraction_rule_12 {
          input: """ SELECT * FROM ext_has_spouse_features_input
          """
          output_relation: "has_spouse_features"
          udf: ${APP_HOME}"/udf/ext_has_spouse_features.py"
          style: "tsv_extractor" 
          dependencies: [ "extraction_rule_13" ]
        }
      

        deepdive.extraction.extractors.extraction_rule_9 {
          input: """ SELECT * FROM ext_has_spouse_input
          """
          output_relation: "has_spouse_candidates"
          udf: ${APP_HOME}"/udf/ext_has_spouse.py"
          style: "tsv_extractor" 
          dependencies: [ "extraction_rule_10" ]
        }
      

        deepdive.inference.factors.has_spouse_0 {
          input_query: """
          SELECT R0.id AS "has_spouse.R0.id" , R2.feature AS "dd_weight_column_0" 
          FROM has_spouse R0, has_spouse_candidates R1, has_spouse_features R2
        WHERE R1.relation_id = R0.relation_id  AND R2.relation_id = R0.relation_id """
          function: "Imply(has_spouse.R0.label)"
          weight: "?(dd_weight_column_0)"
        }
      

        deepdive.inference.factors.has_spouse_1 {
          input_query: """
          SELECT R0.id AS "has_spouse.R0.id" , R1.id AS "has_spouse.R1.id" 
          FROM has_spouse R0, has_spouse R1, has_spouse_candidates R2, has_spouse_candidates R3
        WHERE R2.relation_id = R0.relation_id  AND R3.person1_id = R2.person2_id  AND R3.person2_id = R2.person1_id  AND R3.relation_id = R1.relation_id """
          function: "Imply(has_spouse.R1.label, has_spouse.R0.label)"
          weight: "3.0"
        }
      
deepdive.pipeline.run: ${PIPELINE}
deepdive.pipeline.pipelines.initdb: [extraction_rule_1, extraction_rule_3, extraction_rule_5, extraction_rule_0, extraction_rule_4, extraction_rule_2]
deepdive.pipeline.pipelines.extraction: [extraction_rule_7, extraction_rule_12, extraction_rule_10, extraction_rule_13, extraction_rule_9, extraction_rule_15, extraction_rule_6]
deepdive.pipeline.pipelines.inference: [has_spouse_0, has_spouse_1]
deepdive.pipeline.pipelines.endtoend: [extraction_rule_7, extraction_rule_12, extraction_rule_10, extraction_rule_13, extraction_rule_9, extraction_rule_15, extraction_rule_6, has_spouse_0, has_spouse_1]
deepdive.pipeline.pipelines.cleanup: [cleanup]
